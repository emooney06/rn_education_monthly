import pandas as pd
import os
from functools import reduce
import string
import numpy as np
import collections
import smtplib,ssl
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email.utils import formatdate
from email import encoders
import re
from datetime import datetime


edu_data_path = os.path.join('C:\\', 'Users', 'ejmooney', 'Desktop', 'testData', 'rnEducation.xls')
hr_data_path =os.path.join('C:\\', 'Users', 'ejmooney', 'Desktop', 'testData', 'hrReport.xls')
test_path =os.path.join('C:\\', 'Users', 'ejmooney', 'Desktop', 'testData', 'testData.xlsx')
tempPat =os.path.join('C:\\', 'Users', 'ejmooney', 'Desktop', 'testData', 'tempFile.xlsx')
master_alias_path =os.path.join('C:\\', 'Users', 'ejmooney', 'Desktop', 'testData', 'MasterAlias.xlsx')
edu_job_codes_path =os.path.join('C:\\', 'Users', 'ejmooney', 'Desktop', 'testData', 'jobCodesMasterList.xlsx')

#edu_data_path = os.path.join('C:\\', 'Users', 'Ethan', 'OneDrive', 'Desktop', 'testData', 'rnEducation.xls')
#hr_data_path =os.path.join('C:\\', 'Users', 'Ethan', 'OneDrive', 'Desktop', 'testData', 'hrReport.xls')
#test_path =os.path.join('C:\\', 'Users', 'Ethan', 'OneDrive', 'Desktop', 'testData', 'testData.xlsx')

eduDict = {
'Advanced Practice Nurse': 0,
'Associate Degree -Nursing': 10,
'Associate of Arts Degree - Non-Nursing': 0,
'Associate of Science Degree - Non-Nursing': 0,
'Bachelors of Art':	0,
'Bachelors of Bus Admin': 0,
'Bachelors Science': 0,
'Bachelors Science Nursing': 100,
'Certified Nurse Practitioner':	0,
'Clincal Nurse Specialist':	100,
'Diploma - RN':	1,
'Doctor of Education': 0,
'Doctor of Nursing Practice': 10000,
'Doctor of Nursing Practice - Candidate': 0,
'Doctor of Oriental Medicine': 0,
'Doctor of Oriental Medicine - Candidate': 0,
'Doctor of Philosophy - Nursing': 10000,
'Doctor of Philosophy - Other Discipline':	0,
'Doctor of Philosophy (nursing) - Candidate': 0,
'Doctor of Philosophy (other) - Candidate':	0,
'Licensed Practical Nurse':	0,
'Master Public Health Nursing':	1000,
'Masters Business Administration': 0,
'Masters Degree - Other': 0,
'Masters of Arts': 0,
'Masters Public Health': 0,
'Masters Science': 0,
'Masters Science Nursing': 1000,
'Nurse Practitioner Specialist': 1000,
'Other - Foreign RN Education':	0
}

def intToDegree(row):
    if 10 > row['eduScore'] > 0 :
        val = 'Diploma'
    elif 100 > row['eduScore'] > 9:
        val = 'ADN'
    elif 1000 > row['eduScore'] >99:
        val = 'BSN'
    elif 10000 > row['eduScore'] >999:
        val = 'MSN'
    elif row['eduScore'] > 9999:
        val = 'PhD or DNP'
    else: 
        val = 'Nursing Foreign or Unknown Degree'
    return val;

def inProgressCorrection(row):
    if row['Degree Category'] == 'In Progress':
        val = 0
    else: 
        val = 1
    return val;


edu_data = pd.read_excel(edu_data_path)
hr_data = pd.read_excel(hr_data_path)
edu_job_codes = pd.read_excel(edu_job_codes_path, 'RN_Education')


#Need to change EEID to ID in HR report

# combine the education data and HR data
edu_hr_comb = reduce(lambda x,y: pd.merge(x,y, on='ID', how='left'), [hr_data, edu_data])
# Reduce the set of columns to those columns that are usefule
edu_hr_comb = edu_hr_comb[['Cost Center', 'ID', 'Unit', 'Name_x', 'JOB', 'Title',  'Description', 'Degree Category']]


exclusion_list = edu_job_codes['excl_job_codes'].tolist()
#job_codes_list = edu_hr_comb['JOB'].tolist()
#list(set(job_codes_list))

for i in exclusion_list:
    print('the job code is: ')
    print(i)
    edu_hr_comb = edu_hr_comb[edu_hr_comb.JOB != i]

#edu_hr_comb = edu_hr_comb.dropna(subset=['Description'])

edu_hr_comb.to_excel(test_path)
# correct for "in progress status" by adding a column of 0 for in progress and 1 for all else
edu_hr_comb['multInProgr'] = edu_hr_comb.apply (lambda row: inProgressCorrection(row), axis=1)
edu_hr_comb.to_excel(test_path)
# change the title cost center and ID to string to protect them from the sum function later truncated
edu_hr_comb[['Title', 'Cost Center', 'ID']] = edu_hr_comb[['Title', 'Cost Center', 'ID']].astype(str)
edu_hr_comb.to_excel(test_path)

#edu_hr_comb = edu_hr_comb[~edu_hr_comb['Title'].str.contains('LPN')]
#edu_hr_comb.to_excel(test_path)
# convert the calendar to the integer (bit mask) based on the eduDictionary - this is the eduScore
edu_hr_comb['eduScore']= edu_hr_comb['Description'].map(eduDict)
edu_hr_comb.to_excel(test_path)

# make any null value in the eduScore column a zero so when it is multiplied by the degree in progress indicator
#   the product will be zero (indicating no degree was specified.
edu_hr_comb['eduScore'] = edu_hr_comb['eduScore'].fillna(0)
edu_hr_comb.to_excel(test_path)

# multiply the eduScore and multInProg values to get the adjustment for degrees in progress
edu_hr_comb['eduScore'] = edu_hr_comb['eduScore'] * edu_hr_comb['multInProgr']
edu_hr_comb.to_excel(test_path)



# group by rows that will be duplicate so the eduScore integer (bit mask) can be summed
edu_hr_comb2= edu_hr_comb.groupby(['Name_x', 'Title', 'Cost Center','ID', 'JOB']).sum().reset_index()
edu_hr_comb2.to_excel(test_path)


hr_data = hr_data[['ID', 'Department']]
hr_data['ID'] = hr_data['ID'].astype(str)

edu_hr_comb2 = reduce(lambda x,y: pd.merge(x,y, on='ID', how='left'), [edu_hr_comb2, hr_data])





#edu_hr_comb2['eduScore'] = edu_hr_comb2['eduScore'].astype(int)
edu_hr_comb2['corrEdu'] = edu_hr_comb2.apply (lambda row: intToDegree(row), axis=1)
edu_hr_comb2.to_excel(test_path)

# drop the columns the eduScore and multInProgress columns that are no longer needed - this becomes a duplicate 
# process a few lines later
#edu_hr_comb2 = edu_hr_comb2.drop(columns=['eduScore', 'multInProgr'])
#edu_hr_comb2.to_excel(test_path)

# *** Testing, can change variable name when ready for prod
test = pd.read_excel(test_path)
# Reduce the dataframe to columns that are needed now and re-order to make more readable
test = test[['Cost Center', 'Department', 'Name_x', 'Title', 'JOB', 'corrEdu',]]
# make cost center a string so the left 4 digits can be truncated
test['Cost Center'] = test['Cost Center'].astype(str)
# truncate the cost center to the common 5-digit cost center
test['Cost Center'] = test['Cost Center'].str[4:]
test.to_excel(test_path)

# convert cost center back to integer so it can be used to match a list of integer versions of cost center
test['Cost Center'] = test['Cost Center'].astype(int)
test.to_excel(test_path)

# main alias sheet from masterAliasRecord to a dataframe
alias_df = pd.read_excel(master_alias_path, 'MainAlias')
# limit alias dataframe to cost center and UD Email
alias_df = alias_df[['Cost_Center', 'UD_Email']]
# convert the alias record to a dictionary
email_dict = alias_df.set_index('Cost_Center')['UD_Email'].to_dict()
# get the cost centers to iterate through from the alias dataframe; make it a list
cost_center_list = alias_df['Cost_Center'].values.tolist()

date_month = datetime.today().strftime('%Y-%m')

x = 0
#alias list is a list of all cost centers from MasterAliasRecord
for line in cost_center_list:
    print(line)
    # variable cost_center be what the cost center is for this iteration
    cost_center = line
    str_cost_center = str(cost_center)
    print(cost_center)
    # try and except block is used because not every cost center has a Unit Director email, without
    #   the try and except block it will throw exception error when one of these are encountered
    try:
        #cost_center = str(cost_center)
        # initialize variable that is email address which is a found from the email dictionary object
        email = email_dict.get(cost_center)
        print('The email address is: ')
        print(email)
    except KeyError:
        # If there is no UD Email associated with that cost center, just print it to console
        print('There is no email address for: ') 
        print(cost_center)
    # edu_data is the dataframe of all education data but filtered by the cost center for this iteration
    temp_data = test.loc[test['Cost Center'] == cost_center]
    totals = temp_data['corrEdu'].value_counts()   
    totals = pd.DataFrame(totals)
    totals['degree_pct'] = (totals['corrEdu']/totals['corrEdu'].sum()) * 100 
    totals['degree_pct'] = totals['degree_pct'].round(1)
    totals['degree_pct'] = (totals['degree_pct'].astype(str)) + '%'
    html1 = temp_data.to_html()
    html2 = totals.to_html()

    # me == my email address
    # you == recipient's email address
    me = "ndnqi@salud.unm.edu"
    you = email

    # Create message container - the correct MIME type is multipart/alternative.
    msg = MIMEMultipart('alternative')
    msg['Subject'] = "NDNQI RN Education Data " + date_month + ' ' + str_cost_center
    msg['From'] = me
    msg['To'] = you

    # Create the body of the message (a plain-text and an HTML version).
    text = "Hi!\nHow are you?\nHere is the link you wanted:\nhttps://www.python.org"
    html = html2 + html1

    # Record the MIME types of both parts - text/plain and text/html.
    part1 = MIMEText(text, 'plain')
    part2 = MIMEText(html, 'html')

    # Attach parts into message container.
    # According to RFC 2046, the last part of a multipart message, in this case
    # the HTML message, is best and preferred.
    msg.attach(part1)
    msg.attach(part2)

    # Send the message via local SMTP server.
    s = smtplib.SMTP('HSCLink.health.unm.edu')
    # sendmail function takes 3 arguments: sender's address, recipient's address
    # and message to send - here it is sent as one string.
    s.sendmail(me, you, msg.as_string())
    s.quit()


    x = x + 1


